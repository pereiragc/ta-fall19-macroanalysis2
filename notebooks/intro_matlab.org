#+TITLE: Intro to MATLAB 
#+AUTHOR: Gustavo Pereira
#+OPTIONS: toc:nil num:nil
#+HTML_HEAD: <link rel="stylesheet" href="http://dakrone.github.io/org.css" type="text/css" />


* (Almost) everything is a matrix
  
  - In MATLAB, the most common data type is a matrix of real (or more precisely, floating point) numbers.
  - All the following commands create an object of the type Matrix, with floating point elements: 
  #+begin_src matlab :session :exports code
    u = [1,2.5,3];
    A = [1 2 3; 4 5 6];
    b = 2.5;
    c = pi;
  #+end_src
  - You can inspect dimension of the objects by applying the function ~size~
    #+begin_src matlab :session :exports both
      size(u)
      size(A)
      size(b)
      size(c)
    #+end_src

    #+RESULTS:
    #+begin_example
    size(u)

    ans =

         1     3
    size(A)

    ans =

         2     3
    size(b)

    ans =

         1     1
    size(c)

    ans =

         1     1
    #+end_example
  - There are data types other than matrices. For example
    + structs :: An object that groups sub-objects of any type. 
    + characters/strings :: used to store text
    + tables :: as the name suggests, ; similar to ~data.frame~ in R
  - For details, check out the matlab [[https://www.mathworks.com/help/matlab/data-types.html][documentation]] on data types

** Basic matrix commands
   
   - zeros :: generates a matrix of zeros of specified dimension. 
     #+begin_src matlab :session :exports both
       zeros(2,2)

       zeros(3,1)
     #+end_src

     #+RESULTS:
     #+begin_example
     zeros(2,2)

     ans =

          0     0
          0     0
     zeros(3,1)

     ans =

          0
          0
          0
     #+end_example
   - ones :: similar to ~zeros~, but with ones
   - diag :: if the input is  a
     + /row/column vector/: creates a diagonal matrix whose main diagonal consists of those elements

       #+begin_src matlab :session :exports both
       diag([1,2,5])
       #+end_src

       #+RESULTS:
       : diag([1,2,5])
       : 
       : ans =
       : 
       :      1     0     0
       :      0     2     0
       :      0     0     5
       
     + /matrix/:  extracts the main diagonal of the matrix. 

       #+begin_src matlab :session :exports both

         my_mat = [1, 2, 3; 4, 5, 7]
         diag(my_mat)

       #+end_src

       #+RESULTS:
       #+begin_example
       my_mat = [1, 2, 3; 4, 5, 7]

       my_mat =

            1     2     3
            4     5     7
       diag(my_mat)

       ans =

            1
            5
       #+end_example


* Accessing elements 
  - To access element i,j of a matrix ~M~, use ~M(i,j)~ 
    
    #+begin_src matlab :session :exports both
      M = [10 2 5; 42 1 1];

      M

      M(2,1)
    #+end_src

    #+RESULTS:
    #+begin_example
    M = [10 2 5; 42 1 1];
    M

    M =

        10     2     5
        42     1     1
    M(2,1)

    ans =

        42
    #+end_example

    + For this to work, indices must be "in bounds", i.e., if your matrix is $n\times m$, make sure $i \in \{1,\ldots, n\}$ and $j \in \{1,\ldots, m\}$.

      In the above example, for example ~M(5,1)~ will give an error because the matrix has 2 rows and we're trying to access row number 5.
      #+begin_src matlab :session :exports both

        M(5, 1)

      #+end_src

      #+RESULTS:
      : M(5, 1)
      : <ERRORTXT>
      : Index in position 1 exceeds array bounds (must not exceed 2).
      : </ERRORTXT>
      
* Random numbers

  - In many applications, we need to generate random numbers of a given probability distribution
  - MATLAB has some built-in random number generators: 
    1) Uniform[0,1]
       #+begin_src matlab :session :exports both
         unif_number = rand
         unif_square_mat = rand(3)
         unif_general_mat = rand(3,5)
       #+end_src

       #+RESULTS:
       #+begin_example
       unif_number = rand

       unif_number =

           0.9294
       unif_square_mat = rand(3)

       unif_square_mat =

           0.7757    0.4468    0.5108
           0.4868    0.3063    0.8176
           0.4359    0.5085    0.7948
       unif_general_mat = rand(3,5)

       unif_general_mat =

           0.6443    0.5328    0.8759    0.5870    0.4709
           0.3786    0.3507    0.5502    0.2077    0.2305
           0.8116    0.9390    0.6225    0.3012    0.8443
       #+end_example
    2) Normal(0,1)
       
       #+begin_src matlab :session :exports both 
         stdnorm_number = randn
         stdnorm_square_mat = randn(3)
         stdnorm_general_mat = randn(3,5)
       #+end_src
  - Importantly, every subsequent draw of a random number, within a vector or otherwise, is *independent* of previous draws
   
*** Exercises
    1) Create a 15x1 vector where each component is drawn independent from a
       Uniform[0, 1] distribution
    2) Create a 2x2 matrix where all elements but (2,1) are independent standard
       normal, and entry (2,1) is uniform[0,1].
    3) Create a 2x2 matrix where all elements are drawn independent U[-1, 2]
    4) Create a 2x2 matrix where all elements are drawn independent N(1, 0.16)

  
** Seeding and reproducibility
   
   - Note that if I type ~rand~ here and you do the same on your computer, the
     output will be two different numbers
   - Problem: if I haven't seen you actually generate the number, how do I know it's random?
   - If my results depend on simulation, I might have just made up random-looking numbers that have some desired output
   - To avoid that, *always seed code that uses simulations*. 

     To generate a random number generator seed, use ~rng~:
     #+begin_src matlab :session :exports both
       rng(123)

       my_random_number = rand
     #+end_src

     #+RESULTS:
     : rng(123)
     : my_random_number = rand
     : 
     : my_random_number =
     : 
     :     0.6965
     will consistently output 0.6965, on anyone's computer. 


* IN_PROGRESS Plotting
  - The main plotting command for 2d plots is ~plot~
  - Examples: 
    1) Plotting the square function for integers from 1 to 100
       #+begin_src matlab :session :results file graphics :exports both :file ./output/example1.png
         x = 1:100;
         y = x.^2;

         plot(x,y);
       #+end_src

       #+RESULTS:
       [[file:./output/example1.png]]
       
    2) Note how Matlab creates a line by default. You can change this with the third argument in the plot function. For example,  
       #+begin_src matlab :session :results file graphics :exports both :file ./output/example2.png
         plot(x,y, 'o');
       #+end_src

       #+RESULTS:
       [[file:./output/example2.png]]
       
       - That literally sets 'o' instead of a line. You can use '--' for a dashed line, '-.' for a dashed-dotted line, '+' for pluses, among other options
    3) For setting a color, append the starting letter of a sufficiently normal color. For example, '--r' will set a red dashed line.
       #+begin_src matlab :session :results file graphics :exports both :file ./output/example3.png
         plot(x,y, '--r');
       #+end_src

       #+RESULTS:
       [[file:./output/example3.png]]
      
         
** TODO Subplots

** TODO Saving results

** TODO Two ways of plotting the density of a Chi^2 distribution 
   - In this section, we will plot (an approximation of) the density function of a $\chi^2(q)$ distribution


* IN_PROGRESS Functions
  - An important part of sane programming is to decompose your code in independent modules
  - That is crucial for *code reuse* and *readability*
  

  - Consider the following example. Suppose you have a matrix $M$
    
    #+begin_src matlab :session
      rng(123)

      % Randomly generated matrix
      M = rand(5)
    #+end_src

